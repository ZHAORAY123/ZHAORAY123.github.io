<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>ZHAORAY&#39;s Blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="ZHAORAY&#39;s Blogs">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="ZHAORAY&#39;s Blogs">
<meta property="og:locale" content="zh_cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZHAORAY&#39;s Blogs">
  
    <link rel="alternate" href="/atom.xml" title="ZHAORAY&#39;s Blogs" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ZHAORAY&#39;s Blogs</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">抽烟喝酒敲代码,和我的小弟阿虎虎</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-初探内存管理_二(ARC警告!)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/04/初探内存管理_二(ARC警告!)/" class="article-date">
  <time datetime="2019-04-03T17:09:20.000Z" itemprop="datePublished">2019-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/04/初探内存管理_二(ARC警告!)/">初探内存管理-二(ARC机制的使用规则)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ARC谨记"><a href="#ARC谨记" class="headerlink" title="ARC谨记! ! !"></a>ARC谨记! ! !</h1><h4 id="据苹果公布的几条重要的ARC使用规则-我摘录如下几条"><a href="#据苹果公布的几条重要的ARC使用规则-我摘录如下几条" class="headerlink" title="据苹果公布的几条重要的ARC使用规则,我摘录如下几条:"></a>据苹果公布的几条重要的ARC使用规则,我摘录如下几条:</h4><p>1️⃣ <strong>不能调用<code>dealloc</code>,不能重写和调用<code>retain</code>,<code>release</code>,<code>retainCount</code>和<br><code>autorelease</code>, 一样的像 <code>@selector(retain)</code>,<code>@selector(release)</code>,这些曲线救国的方法也不能调用.</strong></p>
<ul>
<li><code>dealloc</code>虽然可以被重写,但是不可以带哦用<code>[super dealloc]</code>之类的方法!</li>
<li><code>CoreFoundation</code>框架不属于cocoa框架,所以他的<code>CFRetain</code>和<code>CFRelease</code>依然可以使用</li>
</ul>
<hr>
<p>2️⃣ <strong>不能使用NSAllocateObjetc 或 NSDeallocate`函数来<em>创建对象</em></strong>,比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id obj = NSAllocateObject = NSAllocateObject([NSObject class],0 ,nil];</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="3️⃣-禁止在C语言的结构体中使用指针-同时建议用OC的类来管理数据而不是结构体"><a href="#3️⃣-禁止在C语言的结构体中使用指针-同时建议用OC的类来管理数据而不是结构体" class="headerlink" title="3️⃣ 禁止在C语言的结构体中使用指针,同时建议用OC的类来管理数据而不是结构体."></a>3️⃣ <strong>禁止在C语言的结构体中使用指针,同时建议用OC的类来管理数据而不是结构体.</strong></h2><p>4️⃣ </p>
<h2 id="id和void-的转换的正确对待"><a href="#id和void-的转换的正确对待" class="headerlink" title="id和void 的转换的正确对待"></a>id和void 的转换的正确对待</h2><h2 id="NSString和CFStringRef是桥接的关系-可以直接互通使用-但是我们使用之前必须加上关键字"><a href="#NSString和CFStringRef是桥接的关系-可以直接互通使用-但是我们使用之前必须加上关键字" class="headerlink" title="NSString和CFStringRef是桥接的关系,可以直接互通使用,但是我们使用之前必须加上关键字"></a><code>NSString</code>和<code>CFStringRef</code>是桥接的关系,可以直接互通使用,但是我们使用之前必须加上关键字</h2><p><strong>_bridge</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *string = @&quot;test&quot;;</span><br><span class="line">CFStringRef cfString = (__bridge CFStringRef)string;</span><br></pre></td></tr></table></figure></p>
<p><strong>_bridge_retained</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSString *string = @&quot;test&quot;;</span><br><span class="line">CFStringRef cfString = (_bridge_retained CFStringRef) string;</span><br><span class="line">//由于Core Foundation的对象不属于ARC的管理范围,所以他需要自己释放内存</span><br><span class="line">CFRelease(cfString);</span><br></pre></td></tr></table></figure></p>
<p><strong>_bridge_transfer</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFStringRef cfString = CFStringCreateWithCfString(KCFAllocatorSystemDefault,</span><br><span class="line">                          &quot;abc&quot;,</span><br><span class="line">                          KCFStringEncodingMacRoman);</span><br><span class="line">NSString *string = (_bridge_transfer NSString *) cfString;</span><br><span class="line">//因为已经使用了_bridge_transfer转移了对象的所有权,所以不需要调用release</span><br><span class="line">//CFRelease(cfString)</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="5️⃣-不能使用NSAutoreleasePool对-ARC中-全部用-autorelease关键字代替-且比NSAutorelease更高效"><a href="#5️⃣-不能使用NSAutoreleasePool对-ARC中-全部用-autorelease关键字代替-且比NSAutorelease更高效" class="headerlink" title="5️⃣ 不能使用NSAutoreleasePool对.ARC中,全部用@autorelease关键字代替,且比NSAutorelease更高效"></a>5️⃣ 不能使用<code>NSAutoreleasePool</code>对.ARC中,全部用<code>@autorelease</code>关键字代替,且比<code>NSAutorelease</code>更高效</h2><h2 id="6️⃣-不得使用内存Zone-以及那些设计NSZone相关的方法"><a href="#6️⃣-不得使用内存Zone-以及那些设计NSZone相关的方法" class="headerlink" title="6️⃣ 不得使用内存Zone,以及那些设计NSZone相关的方法"></a>6️⃣ <strong>不得使用内存<code>Zone</code>,以及那些设计<code>NSZone</code>相关的方法</strong></h2><p>##7️⃣不得对一个属性变量的取值方法命名为 new 开头,譬如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (strong,nonatomic) NSString *newName;//错误,取值方法名为newName</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="8️⃣outLet均用weak关键字修饰-除非他是xib中中顶部的界面元素-则需要用strong-否则xib-一旦创建完成-就自动销毁"><a href="#8️⃣outLet均用weak关键字修饰-除非他是xib中中顶部的界面元素-则需要用strong-否则xib-一旦创建完成-就自动销毁" class="headerlink" title="8️⃣outLet均用weak关键字修饰,除非他是xib中中顶部的界面元素,则需要用strong,否则xib 一旦创建完成,就自动销毁"></a>8️⃣outLet均用weak关键字修饰,除非他是xib中中顶部的界面元素,则需要用strong,否则xib 一旦创建完成,就自动销毁</h2><h2 id="9️⃣Core-Foundation不使用ARC-该创建的依然创建-该释放的必须释放"><a href="#9️⃣Core-Foundation不使用ARC-该创建的依然创建-该释放的必须释放" class="headerlink" title="9️⃣Core Foundation不使用ARC,该创建的依然创建,该释放的必须释放!"></a>9️⃣Core Foundation不使用ARC,该创建的依然创建,该释放的必须释放!</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/04/初探内存管理_二(ARC警告!)/" data-id="cju1icrdx00004y561h9cpcvf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-源码资源-收集" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/03/源码资源-收集/" class="article-date">
  <time datetime="2019-04-03T15:40:54.000Z" itemprop="datePublished">2019-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/03/源码资源-收集/">源码资源_收集</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>bireme 大佬的iOS 保持界面流畅的技巧</p>
<p><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/</a></p>
<p>深入理解RunLoop</p>
<p><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/05/18/runloop/</a></p>
<p>iOS线下分享《RunLoop》by 孙源@sunnyxx</p>
<p><a href="https://v.youku.com/v_show/id_XODgxODkzODI0.html" target="_blank" rel="noopener">https://v.youku.com/v_show/id_XODgxODkzODI0.html</a></p>
<p>objc 中的 block</p>
<p><a href="https://blog.ibireme.com/2013/11/27/objc-block/" target="_blank" rel="noopener">https://blog.ibireme.com/2013/11/27/objc-block/</a></p>
<p>RunLoop</p>
<p><a href="https://juejin.im/post/5add46606fb9a07abf721d1d" target="_blank" rel="noopener">https://juejin.im/post/5add46606fb9a07abf721d1d</a></p>
<p>关于ARC实现的一些总结 </p>
<p><a href="https://www.jianshu.com/p/b13983e341fd" target="_blank" rel="noopener">https://www.jianshu.com/p/b13983e341fd</a></p>
<h2 id="博客园整理："><a href="#博客园整理：" class="headerlink" title="博客园整理："></a>博客园整理：</h2><p>iOS 类方法 、野指针与空指针</p>
<p><a href="https://www.cnblogs.com/jukaiit/p/10097134.html" target="_blank" rel="noopener">https://www.cnblogs.com/jukaiit/p/10097134.html</a></p>
<p>iOS 多线程 NSOperation、NSOperationQueue</p>
<p><a href="https://www.cnblogs.com/jukaiit/p/10038893.html" target="_blank" rel="noopener">https://www.cnblogs.com/jukaiit/p/10038893.html</a></p>
<p>iOS多线程GCD的使用</p>
<p><a href="https://www.cnblogs.com/jukaiit/p/10038213.html" target="_blank" rel="noopener">https://www.cnblogs.com/jukaiit/p/10038213.html</a></p>
<p>iOS Block界面反向传值</p>
<p><a href="https://www.cnblogs.com/jukaiit/p/5051485.html" target="_blank" rel="noopener">https://www.cnblogs.com/jukaiit/p/5051485.html</a></p>
<p>iOS Block简介</p>
<p><a href="https://www.cnblogs.com/jukaiit/p/5050982.html" target="_blank" rel="noopener">https://www.cnblogs.com/jukaiit/p/5050982.html</a></p>
<p>Objective-C Block与函数指针比较</p>
<p><a href="https://www.cnblogs.com/jukaiit/p/9686872.html" target="_blank" rel="noopener">https://www.cnblogs.com/jukaiit/p/9686872.html</a></p>
<p>Runtime的使用</p>
<p><a href="https://www.cnblogs.com/jukaiit/p/5242211.html" target="_blank" rel="noopener">https://www.cnblogs.com/jukaiit/p/5242211.html</a></p>
<p>App瘦身、性能优化总结</p>
<p><a href="https://www.cnblogs.com/jukaiit/p/10506009.html" target="_blank" rel="noopener">https://www.cnblogs.com/jukaiit/p/10506009.html</a></p>
<p>iOS App稳定性指标及监测</p>
<p><a href="https://www.cnblogs.com/jukaiit/p/8145388.html" target="_blank" rel="noopener">https://www.cnblogs.com/jukaiit/p/8145388.html</a></p>
<p>iOS 如何优化 App 的启动时间</p>
<p><a href="https://www.cnblogs.com/jukaiit/p/8110401.html" target="_blank" rel="noopener">https://www.cnblogs.com/jukaiit/p/8110401.html</a></p>
<p>weakSelf 和 strongSelf</p>
<p><a href="https://www.cnblogs.com/jukaiit/p/8018883.html" target="_blank" rel="noopener">https://www.cnblogs.com/jukaiit/p/8018883.html</a></p>
<p><strong>Block与</strong>Weak区别</p>
<p><a href="https://www.cnblogs.com/jukaiit/p/5833920.html" target="_blank" rel="noopener">https://www.cnblogs.com/jukaiit/p/5833920.html</a></p>
<p>iOS 字典或者数组和JSON串的转换</p>
<p><a href="https://www.cnblogs.com/jukaiit/p/5795833.html" target="_blank" rel="noopener">https://www.cnblogs.com/jukaiit/p/5795833.html</a></p>
<p>iOS 事件传递响应链</p>
<p><a href="https://www.cnblogs.com/jukaiit/p/5574615.html" target="_blank" rel="noopener">https://www.cnblogs.com/jukaiit/p/5574615.html</a></p>
<p>冒泡排序的实现</p>
<p><a href="https://www.cnblogs.com/jukaiit/p/5515498.html" target="_blank" rel="noopener">https://www.cnblogs.com/jukaiit/p/5515498.html</a></p>
<p>iOS中延时执行的几种方式的比较和汇总</p>
<p><a href="https://www.cnblogs.com/jukaiit/p/5054951.html" target="_blank" rel="noopener">https://www.cnblogs.com/jukaiit/p/5054951.html</a></p>
<p>iOS 3DES加密解密(一行代码搞定)</p>
<p><a href="https://www.cnblogs.com/jukaiit/p/5039803.html" target="_blank" rel="noopener">https://www.cnblogs.com/jukaiit/p/5039803.html</a></p>
<p><a href="https://www.cnblogs.com/jukaiit/p/7932259.html" target="_blank" rel="noopener">https://www.cnblogs.com/jukaiit/p/7932259.html</a></p>
<p><a href="https://www.cnblogs.com/jukaiit/p/7932139.html" target="_blank" rel="noopener">https://www.cnblogs.com/jukaiit/p/7932139.html</a></p>
<p><a href="https://www.cnblogs.com/jukaiit/p/7932313.html" target="_blank" rel="noopener">https://www.cnblogs.com/jukaiit/p/7932313.html</a></p>
<h2 id="掘金文章："><a href="#掘金文章：" class="headerlink" title="掘金文章："></a>掘金文章：</h2><p>2018年 iOS 面试心得</p>
<p><a href="https://juejin.im/post/5b4cd5aae51d455b5d3efa2c" target="_blank" rel="noopener">https://juejin.im/post/5b4cd5aae51d455b5d3efa2c</a></p>
<p><a href="https://juejin.im/post/5a7c011d5188257a654cc76d" target="_blank" rel="noopener">https://juejin.im/post/5a7c011d5188257a654cc76d</a></p>
<p><a href="https://juejin.im/post/5a3b12daf265da433227ba91" target="_blank" rel="noopener">https://juejin.im/post/5a3b12daf265da433227ba91</a></p>
<p><a href="https://juejin.im/post/5c989fd15188252d5255f7f3" target="_blank" rel="noopener">https://juejin.im/post/5c989fd15188252d5255f7f3</a></p>
<p><a href="https://juejin.im/post/5c95e75df265da60f6730f0c" target="_blank" rel="noopener">https://juejin.im/post/5c95e75df265da60f6730f0c</a></p>
<p>iOS-Runloop 常驻线程／性能优化</p>
<p><a href="https://juejin.im/entry/58b93b72ac502e006bdf7527" target="_blank" rel="noopener">https://juejin.im/entry/58b93b72ac502e006bdf7527</a></p>
<h2 id="iOS-好文源码收藏CocoaChina"><a href="#iOS-好文源码收藏CocoaChina" class="headerlink" title="iOS 好文源码收藏CocoaChina"></a>iOS 好文源码收藏CocoaChina</h2><p>Swift 优雅的适配大小</p>
<p> <a href="http://www.cocoachina.com/ios/20181025/25289.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20181025/25289.html</a></p>
<p>iOS：一分钟集成主流APP个人资料页</p>
<p><a href="http://www.cocoachina.com/ios/20181219/23578.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20181219/23578.html</a></p>
<p>30个让你眼前一亮的iOS Swift UI控件!</p>
<p><a href="http://www.cocoachina.com/ios/20190228/26435.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20190228/26435.html</a></p>
<p>iOS 电商demo（实现各种常见动画效果和页面布局）</p>
<p><a href="http://www.cocoachina.com/ios/20190215/26342.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20190215/26342.html</a></p>
<p>每个APP都用得上的SegmentedView Swift</p>
<p><a href="http://www.cocoachina.com/ios/20190215/26296.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20190215/26296.html</a></p>
<p>iOS上的顶部提示栏</p>
<p><a href="http://www.cocoachina.com/ios/20190118/26168.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20190118/26168.html</a></p>
<p>iOS 如何高效的使用多线程</p>
<p><a href="http://www.cocoachina.com/ios/20181224/25922.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20181224/25922.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/03/源码资源-收集/" data-id="cju1ian0l00063j567k4lxv21" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-进程内存是如何分区的" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/03/进程内存是如何分区的/" class="article-date">
  <time datetime="2019-04-02T16:59:10.000Z" itemprop="datePublished">2019-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/03/进程内存是如何分区的/">进程内存是如何分区的</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>#进程的内存分区</p>
<blockquote>
</blockquote>
<p><strong>代码区</strong></p>
<ul>
<li>存放代码，只读防止运行时被修改。</li>
</ul>
<p><strong>常量区</strong></p>
<blockquote>
</blockquote>
<p><strong>全局(静态)区</strong></p>
<ul>
<li>数据区<br>静态存储方式下，变量被分配的空间，放在这里的变量已经初始化。</li>
<li>BSS<br>同数据区相同，只不过放在这里的变量还没有初始化。</li>
</ul>
<blockquote>
<p><strong>堆</strong></p>
<ul>
<li><strong>动态存储方式</strong>下，变量被分配的空间,它大小并不固定，可动态扩张或缩减。当进程调用alloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用realse释放内存时，被释放的内存从堆中被剔除（堆被缩减）。<strong>放在这里的变量需要程序员手动管理</strong>(ARC本质上还是属于手动管理)。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>栈</strong></p>
<ul>
<li><strong>动态存储</strong>方式下，变量被分配的空间，此时变量由操作系统和编译器管理。并不需要人为管理</li>
</ul>
</blockquote>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/03/进程内存是如何分区的/" data-id="cju1ian0n00093j56f2gb9v1w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-初探内存管理-一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/02/初探内存管理-一/" class="article-date">
  <time datetime="2019-04-02T11:40:42.000Z" itemprop="datePublished">2019-04-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/02/初探内存管理-一/">初探内存管理(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>OC中有两种两种内存管理:<br>1️⃣<strong>在家吃饭</strong>:自己做饭自己擦桌子:自己申请内存自己释放(省钱,自由)<br>2️⃣<strong>在馆子吃饭</strong>:自己申请由自动释放池释放(省事,不用自己动手)</p>
<h1 id="1-内存的创建与释放-手动"><a href="#1-内存的创建与释放-手动" class="headerlink" title="1.内存的创建与释放(手动)"></a>1.内存的创建与释放(手动)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define RELEASE(obj) if(!obj)&#123; [obj release]; obj = nil; &#125;</span><br><span class="line">//创建</span><br><span class="line">id  testObject = [[ClassName alloc] init];     </span><br><span class="line">//释放</span><br><span class="line">if (testObject) &#123;</span><br><span class="line">[testObject release];</span><br><span class="line">testObject = nil;//虽然内存被释放,但是其指针地址还存在,指向一块无用的内存地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>alloc</code>创建了一块只属于testObject的内存<br><code>retain</code>也会将对象的引用计数+1 <strong>什么是copy?retain?</strong> 接下来会讲!<br><code>release</code>将对象的引用计数-1;</p>
<h1 id="2-自动释放池的使用-自动"><a href="#2-自动释放池的使用-自动" class="headerlink" title="2.自动释放池的使用 (自动)"></a>2.自动释放池的使用 (自动)</h1><p>所有在runtime环境中的程序,都会在程序的主消息循环中的自动释放池里面运作,当然就是在main()函数里的自动释放池的闭包,代码似乎是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[] &#123;</span><br><span class="line">    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];</span><br><span class="line">    int retVal = UIApplicationMain(argc, argv,nil,nil);</span><br><span class="line">    [pool release];</span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>alloc</code>: +1<br><code>autorelease</code>: -1<br><strong>catch your attention!</strong></p>
<ul>
<li>不再需要也不再允许去<strong>手动释放</strong>testObject,因为他的引用计数会变为0,不需要你费心</li>
<li>testObject超出它的作用域,会被”自动释放池”释放,无法继续使用</li>
<li>PS: 只需要负责自己的对象的创建位置和作用域,他的释放无需你操心             </li>
</ul>
<h5 id="特殊-如果一个对象被加入自动释放池-又以某个函数的身份返回出去-那么他的作用域相应地也扩大到了外面调用者那层-这个对象并不会因为autorelease而在返回出去的时候系统自动释放其内存"><a href="#特殊-如果一个对象被加入自动释放池-又以某个函数的身份返回出去-那么他的作用域相应地也扩大到了外面调用者那层-这个对象并不会因为autorelease而在返回出去的时候系统自动释放其内存" class="headerlink" title="特殊:如果一个对象被加入自动释放池,又以某个函数的身份返回出去.那么他的作用域相应地也扩大到了外面调用者那层,这个对象并不会因为autorelease而在返回出去的时候系统自动释放其内存"></a>特殊:如果一个对象被加入自动释放池,又以某个函数的身份返回出去.那么他的作用域相应地也扩大到了外面调用者那层,这个对象并不会因为autorelease而在返回出去的时候系统自动释放其内存</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*  生成自动释放的实例test */</span><br><span class="line">- (NSString) testAutoReleasePool &#123; 1️⃣</span><br><span class="line">    NSString *test = [[NSString alloc] initWithString:@&quot;testAutorelease&quot;];</span><br><span class="line">    return [test autorelease];</span><br><span class="line">&#125;</span><br><span class="line">/* 调用test 并且作用域从1️⃣扩大为2️⃣ */</span><br><span class="line">- (void) invokeTestMethod &#123; </span><br><span class="line">    NSString *testMethod = [self testAutoReleasePool];2️⃣</span><br><span class="line">    NSLog(@&quot;%@&quot;,testMethod);</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"># retain(保留)对象</span><br><span class="line">我们现在有一个问题,自动释放池会帮我们自动处理内存的释放,可是控制控制权并不在我们手里,**万一我们要使用的对象被释放了怎么办?**</span><br></pre></td></tr></table></figure>
<p>@interface ClassName: NSObject<br>{<br>    NSFileManager *_fileMgr;//成员变量<br>}<br>@end</p>
<p>@implementation ClassName </p>
<ul>
<li>(void) init {<br>  self = [super init];<br>  if (self) {<br>  //等下我们需要更改这里的代码<br>  _fileMgr = [NSFileManager defaultManager];<br>  }<br>  return self;<br>}</li>
<li>(void) dealloc {<br>  if(!_fileMgr) {<pre><code>[_fileMgr release];
_fileMgr = nil;
}
</code></pre>  [super dealloc];<br>  }<br>}<br>@end<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">上面我们采用了NSFileManager类方法来实例化对象,但是我们知道自动释放池的原理,只要所创建的对象超出作用域(**这里是初始化init()方法**),内存自动Release! 怎么办? 主角登场.....Retain!!!!</span><br><span class="line">*我们使用retain将我们上诉标记代码修改如下:*</span><br><span class="line">`_fileMgr = [[NSFileManager defaultManager]retain];`</span><br><span class="line">最后,记得将成员变量放入dealloc中释放其内存.</span><br><span class="line"></span><br><span class="line"># copy(复制)对象</span><br><span class="line">对于那些实现了NSCopying协议的库,我们可以对创建出来的对象copy,对象的引用计数+1</span><br><span class="line">`NSString *strTestA = [[NSString stringWithString:@&quot;Let&apos;s do copy&quot; copy];`</span><br><span class="line">注意:未实现NSCopy协议的类无法使用copy关键字</span><br><span class="line">### copy与retain的异同</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>NSMutableString <em>strOrigin = @”test”;//0x06d760a1<br>NSMutableString </em>strCopy   = [strOrigin copy]; //0x06d888b9<br>NSMutableString *strRetain = [strOrigin retain];//0x06d760a1<br><code>`</code><br><strong>retain使strOrigin引用计数加一,并且指针仍然指向strOrigin<br>但是copy却复制了新的,指向另一块新的内存地址,因此我们需要维护一个全新的指针</strong></p>
<h4 id="Could-I-have-your-attention"><a href="#Could-I-have-your-attention" class="headerlink" title="Could I have your attention?"></a>Could I have your attention?</h4><pre><code>虽然NSString属于一种特殊类,它是一种不可变得常量字符串,由于&quot;享元模式&quot;的影响,
对于某些类来说,即使使用了copy,其返回的指针仍然和原对象的诊治相同,
NSString就属于这一类
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/02/初探内存管理-一/" data-id="cju1ian0g00023j56h07avyiy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-类方法与实例方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/02/类方法与实例方法/" class="article-date">
  <time datetime="2019-04-02T11:11:16.000Z" itemprop="datePublished">2019-04-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/02/类方法与实例方法/">类方法与实例方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-什么是类方法？"><a href="#1-什么是类方法？" class="headerlink" title="1.什么是类方法？"></a>1.什么是类方法？</h1><p>在OC类定义方法时以 + 开头的方法，又称为<strong>静态方法</strong>(<em>可以简单地理解为:在对象还没产生之前,类方法已经存在</em>)。<br>如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (id) stringWithString: (NSString *)  aString;</span><br><span class="line">应用: NSString *strTest = [NSString stringWithString: @&quot;我是类方法&quot;];  </span><br><span class="line">//其中类方法&quot;stringWithString&quot;会为&quot;strTest&quot;自动添加到自动释放池中</span><br></pre></td></tr></table></figure>
<p>其中类方法<code>stringWithString</code>会为<code>strTest</code>创建一块内存.值得注意的是,这块内存已经被加入<code>自动释放池</code>中,<strong>因此类方法创造出来的对象,不需要手动释放</strong></p>
<p><strong>作用</strong>：不用实例化就可以直接调用的方法，一般是有返回值的，返回对应的实例（数组、字符串等），还有<em>可能就是本身类的实例对象</em>。<br>常用于一些common或者UtiKit等公共方法类中。<br><strong>调用</strong>：[类名 方法名】限制： 不能使用自身属性 ，想要使用的类方法就<strong>要在定义类的.h文件中声明哟，否则不能直接调用</strong>！</p>
<h1 id="2-什么是实例方法？"><a href="#2-什么是实例方法？" class="headerlink" title="2.什么是实例方法？"></a>2.什么是实例方法？</h1><p>在OC定义中以 - 开头的方法。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (id) initWithString: (NSString *) aString</span><br><span class="line">应用: NSString *strTest =  [[NSString alloc] initWithString: @&quot;我是实例方法!&quot;];</span><br></pre></td></tr></table></figure></p>
<p><strong>作用</strong>：必须先创建实例对象，相当于回应消息模式。实例对象调用的方法。 </p>
<p><strong>调用</strong>：[对象 方法]<br>可以使用自身属性</p>
<h1 id="ALL-IN-ALL"><a href="#ALL-IN-ALL" class="headerlink" title="ALL IN ALL"></a>ALL IN ALL</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例一个对象personA并且手动将其添加到自动释放池</span></span><br><span class="line">Person personA = [[[Person alloc] init]  autorelease];</span><br><span class="line"><span class="comment">//实例化一个对象personB并且自动将其添加到自动释放池</span></span><br><span class="line">Person personB = [Person person];</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/02/类方法与实例方法/" data-id="cju1ian0m00083j56ibkr9w5o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-日志分析之NSLOG" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/02/日志分析之NSLOG/" class="article-date">
  <time datetime="2019-04-02T07:31:22.000Z" itemprop="datePublished">2019-04-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/02/日志分析之NSLOG/">日志分析之NSLOG</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="NSLOG原理详解"><a href="#NSLOG原理详解" class="headerlink" title="NSLOG原理详解"></a>NSLOG原理详解</h1><p>我们都知道字符串会被NSLog打印在两个地方:macOS的控制台 和 XCode的控制台<br>其实不然,这只是在默认情况下才是正确的,1️⃣打开macOS的控制台,可以在窗口左侧看见由很多个文件组成,<strong>每个文件都会记录各自的日志</strong>:(下图中记录了软件crash日志)<br><img src="/Users/ZhaoRay/Library/Application Support/typora-user-images/image-20190402153802402.png" alt="image-20190402153802402"></p>
<ul>
<li>而对于NSlog来说,它打印的目的地并不是控制台而是系统文件<code>system.log</code>,这个文件存放于”/library/logs/Console.log”路径上.</li>
<li>而NSlog另一个打印目的地也不是Xcode的控制台,而是<em><em>stderr</em></em>(stderr可以重定向打印介质),但是在默认情况下,stderr直接重定向到XCode的控制台中.</li>
</ul>
<p><strong>接下来让我们用两种方法模拟一下NSLOG做的两个事情:system.log 和 stderr:</strong></p>
<h3 id="1-system-log"><a href="#1-system-log" class="headerlink" title="1. system.log"></a>1. system.log</h3><p>首先system.log记录了系统所有的日志内容,为了帮助开发更好地使用日志系统,APPLE贴心地提供了一套完整的API来和日志系统interact.不过令人可惜的是整套API采用的是C语言,归属于ASL(<em>apple system log facility</em>)所有.使用这个API时,请务必引入头文件,代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;asl.h&gt;</span><br></pre></td></tr></table></figure></p>
<p>实现ASL提供的接口:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSString *strTest =  @&quot;testLog&quot;;</span><br><span class="line">aslclient client  = asl_open(NULL, &quot;com.apple.comsole&quot;,0);</span><br><span class="line"></span><br><span class="line">asl_log(client,NULL,ASL_LEVEL_WARNING, &quot;%s&quot; , [strTest UTF8String]);</span><br><span class="line">asL_console(client);</span><br></pre></td></tr></table></figure></p>
<p><strong>执行上述代码后,@”testLog”只会打印在系统文件中,不会向stderr中传递,所以XCode得控制台也不会出现</strong></p>
<h3 id="XCode控制台"><a href="#XCode控制台" class="headerlink" title="XCode控制台"></a>XCode控制台</h3><p>由于MacOS是基于Unix为核心的操作系统,大部分的的Linux命令在Mac中是可以使用的<br>为了让日志打印在XCode控制台中,我们会用的Unix的一个命令writev(),shiyong writev()时引入头文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;sys/uio.h&gt;</span><br></pre></td></tr></table></figure></p>
<p>函数的Man手册写明了接口的格式,如下所示.<br><strong>(PS:Linux老师说的没错,Man是世界上最威猛的男人,看来我也需要深入了解一下这个男人了)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t writev(int fildes, const struct ioves *iov, int iovcnt);</span><br></pre></td></tr></table></figure></p>
<p>writev函数使用的需要三个参数:</p>
<ul>
<li>第一个参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define STUIN_FILENO    0   //标准输入文件描述</span><br><span class="line">#define STUIN_FILENO    1   //标准输出文件描述</span><br><span class="line">define STUIN_FILENO     2   //标准错误描述</span><br><span class="line"></span><br><span class="line">/*显然和stderr打交道,STYERR_FILENO比较适合我们*/</span><br></pre></td></tr></table></figure>
<ul>
<li><p>第二个参数:为内容参数,我们需要传入一个数组,数组中的每个以iovec类型的结构体的元素都需要提前订好iov_base和iov_len两个结构体内部量,在这个数组中,每个元素都是需要打印的内容,所以我们在<code>Terminal</code>中<code>ls -al</code> 看到就是这种.输出目的程序的进程号,进程名,线程号和时间戳等一系列和当前内容相关的元素一并作为元素塞进去打印.</p>
</li>
<li><p>第三个参数是告诉API,第二个参数有多少个,just指定数组大小而已.</p>
</li>
</ul>
<p>这样一来,运行的结果会直接打印在stderr上,和NSlog做的第二件事情一模一样.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">日志在初学阶段可能只是用来验证程序是否正常或者作为Debug的一种手段</span><br><span class="line">但是在后期的工作,起到很重要的作用,用户上传的crash日志和程序运行时日志</span><br><span class="line">是程序调优,解惑的无二秘籍.</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/02/日志分析之NSLOG/" data-id="cju1ian0l00073j564dpfpk0o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-assign" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/01/assign/" class="article-date">
  <time datetime="2019-03-31T18:03:37.000Z" itemprop="datePublished">2019-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/01/assign/">assign与retain之异同</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>IOS的对象都继承于NSObject, 该对象有一个方法:retainCount ，内存引用计数。</p>
<p>alloc对象分配后引用计数为1<br>retain 对象的引用计数+1<br>copy 一个对象变成新的对象(新内存地址) 引用计数为1， 原来对象计数不变<br>release 对象引用计数-1 如果为0释放内存<br>autorelease 对象引用计数-1 如果为0不马上释放，最近一个pool时释放</p>
<p>内存管理的原则是最终的引用计数要平衡：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果最终引用计数大于0，则会内存泄露</span><br><span class="line">如果当引用计数等于0时还对该对象进行操作，则会出现内存访问失败而crash ，所以尽量设置为nil</span><br><span class="line">这两个问题都很严重，所以请一定注意内存释放和不用过后设置为nil。</span><br></pre></td></tr></table></figure></p>
<p>区别(assign,retain,copy):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = [[NSString alloc] initWithString:@&apos;abc&apos;];</span><br></pre></td></tr></table></figure>
<p>上面一段代码会执行以下两个动作:</p>
<p> a. 在堆上分配一段内存用来存储@’abc’ ,比如:内存地址为0X1111 内容为 ‘abc’。</p>
<p> b. 在栈上分配一段内存用来存储str,比如:地址为0XAAAA 内容自然为0X1111。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.assign的情况:NSString *newStr = [str assign];</span><br></pre></td></tr></table></figure>
<p>newStr和str完全相同,地址都是0XAAAA ,内容为0X1111 ,即newStr只是str的别名,对任何一个操作就等于对另一个操作。因此retainCount不需要增加。相当于指针赋值，不对引用计数进行操作，注意原对象不用时，一定要把这个设置为nil。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.retain的情况：NSString * newStr = [str retain];</span><br></pre></td></tr></table></figure></p>
<p>newStr的地址不再为0XAAAA,可能为0XAABB,但是内容依然为0X1111.因此newStr和str都可以管理’abc’所在的内存。因此 retainCount需要增加1。相当于对原对象的引用计数加1</p>
<p>3.copy的情况：NSString * newStr = [str copy];</p>
<p>会在堆上重新开辟一段内存存放@’abc’,比如0X1122,内容为@’abc,同时会在栈上为newStr分配空间,比如地址:0XAACC,内容为0X1122,因此retainCount增加1供newStr来管理0X1122这段内存.</p>
<p>区别(assign与retain)：</p>
<ol>
<li>接触过C，那么假设你用malloc分配了一块内存，并且把它的地址赋值给了指针a，后来你希望指针b也共享这块内存，于是你又把a赋值给（assign）了b。此时a和b指向同一块内存，请问当a不再需要这块内存，能否直接释放它？答案是否定的，因为a并不知道b是否还在使用这块内存，如果a释放了，那么b在使用这块内存的时候会引起程序crash掉。</li>
<li>了解到1中assign的问题，那么如何解决？最简单的一个方法就是使用引用计数（reference counting），还是上面的那个例子，我们给那块内存设一个引用计数，当内存被分配并且赋值给a时，引用计数是1。当把a赋值给b时引用计数增加到2。这时如果a不再使用这块内存，它只需要把引用计数减1，表明自己不再拥有这块内存。b不再使用这块内存时也把引用计数减1。当引用计数变为0的时候，代表该内存不再被任何指针所引用，系统可以把它直接释放掉。<br>总结：上面两点其实就是assign和retain的区别，assign就是直接赋值，从而可能引起1中的问题，当数据为基础数据类型（NSInteger，CGFloat）和C数据类型（int, float, double, char）时，可以使用assign。retain就如2中所述，使用了引用计数，retain引起引用计数加1, release引起引用计数减1，当引用计数为0时，dealloc函数被调用，内存被回收。</li>
</ol>
<p>区别(atomic与nonatomic)：</p>
<p>atomic、nonatomic，决定编译器生成的getter和setter是否为原子操作。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">atomic</span><br><span class="line"></span><br><span class="line">        设置成员变量的<span class="keyword">@property</span>属性时，默认为atomic，提供多线程安全。</span><br><span class="line"></span><br><span class="line">        在多线程环境下，原子操作是必要的，否则有可能引起错误的结果。加了atomic，<span class="keyword">setter</span>函数会变成下面这样：</span><br><span class="line">                &#123;lock&#125;</span><br><span class="line">                        <span class="keyword">if</span> (property != newValue) &#123; </span><br><span class="line">                                [property release]; </span><br><span class="line">                                property = [newValue <span class="keyword">retain</span>]; </span><br><span class="line">                        &#125;</span><br><span class="line">                &#123;unlock&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">nonatomic</span></span><br><span class="line"></span><br><span class="line">禁止多线程，变量保护，提高性能。</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/01/assign/" data-id="cju1ian0e00013j5679kj4yij" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构之串-模式匹配KMP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/01/数据结构之串-模式匹配KMP/" class="article-date">
  <time datetime="2019-03-31T18:03:37.000Z" itemprop="datePublished">2019-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/01/数据结构之串-模式匹配KMP/">数据结构之串-模式匹配KMP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="数据结构算法-串之模式匹配KMP"><a href="#数据结构算法-串之模式匹配KMP" class="headerlink" title="数据结构算法- 串之模式匹配KMP"></a>数据结构算法- 串之模式匹配KMP</h1><p><a href="https://www.cnblogs.com/yjiyjige/p/3263858.html" target="_blank" rel="noopener">https://www.cnblogs.com/yjiyjige/p/3263858.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/01/数据结构之串-模式匹配KMP/" data-id="cju1ian0i00033j56ykkgda3t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-OC类别与类扩展-初探一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/30/OC类别与类扩展-初探一/" class="article-date">
  <time datetime="2019-03-30T15:11:48.000Z" itemprop="datePublished">2019-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/30/OC类别与类扩展-初探一/">OC类别与类扩展(初探一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、类别（Category）-又称-分类"><a href="#一、类别（Category）-又称-分类" class="headerlink" title="一、类别（Category）,又称:分类"></a>一、类别（Category）,又称:分类</h1><h4 id="Ⅰ、类别文件的创建"><a href="#Ⅰ、类别文件的创建" class="headerlink" title="Ⅰ、类别文件的创建"></a>Ⅰ、类别文件的创建</h4><p>1.新建文件<br>2.选择iOS平台Source中的Object-C Fie<br>3.选择File Type为Category，则可建立相应类的类别文件</p>
<h4 id="Ⅱ、类别文件的特征"><a href="#Ⅱ、类别文件的特征" class="headerlink" title="Ⅱ、类别文件的特征"></a>Ⅱ、类别文件的特征</h4><p>类别文件为.h和.m两个<br>命名为”类名+类别名.h”和”类名+类别名.m”</p>
<h4 id="Ⅲ、类别文件格式"><a href="#Ⅲ、类别文件格式" class="headerlink" title="Ⅲ、类别文件格式"></a>Ⅲ、类别文件格式</h4><p><strong>.h文件中的格式为</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;类名.h&quot;</span><br><span class="line">@interface 类名 (类别名)</span><br><span class="line">// 在此处声明方法</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p><strong>.m文件中的格式为</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;类名+类别名.h&quot;</span><br><span class="line">@implementation 类名 (类别名)</span><br><span class="line">// 在此处实现声明的方法</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<h4 id="Ⅳ、类别的作用"><a href="#Ⅳ、类别的作用" class="headerlink" title="Ⅳ、类别的作用"></a>Ⅳ、类别的作用</h4><p>1、拓展当前类，为类添加方法拓展<br>2、</p>
<h4 id="Ⅴ、类别的局限性"><a href="#Ⅴ、类别的局限性" class="headerlink" title="Ⅴ、类别的局限性"></a>Ⅴ、类别的局限性</h4><p>无法向现有的类中添加新的实例变量(类别没有位置容纳实例变量)。<code>Category</code>一般情况下只能为类提供方法的扩展，不提供属性的扩展。但是利用<code>RunTime</code>也可以在<code>Category</code>中添加属性。<br>方法名称冲突，即类别中的新方法的名称与现有类中方法名称重名，类别具有更高的优先级，类别中的方法将完全取代现有类中的方法(再也无法访问现有类中的同名方法)。</p>
<h4 id="Ⅵ、Category使用和注意"><a href="#Ⅵ、Category使用和注意" class="headerlink" title="Ⅵ、Category使用和注意"></a>Ⅵ、Category使用和注意</h4><ul>
<li><code>Category</code>中的方法如果和当前类中已有方法完全相同（这里的相同只除了方法体外的其他地方相同），那么<code>Category</code>相当于重写覆盖掉类中的方法。因为<code>Category</code>优先级最高，当重写了类的方法时，系统会调用<code>Category</code>里的重写方法</li>
<li><code>Category</code>拓展的方法按照有没有重写当前类中的方法，分为未重写的拓展方法和重写拓展方法，<strong>如果类要引用Category中未重写的拓展方法，必须引入Category的声明文件。且类引用自己的Category时，只能在.m实现文件中引用</strong>（如果在.h声明文件中引用自己的类别，会因为头文件原因造成死循环），子类引用父类的类别，在.h或.m文件中引用皆可。如果类引用<code>Category</code>中的重写方法，不用引入<code>Category</code>声明文件，系统会自动调用Category的重写方法</li>
<li><code>Category</code>中如果重写了A类从父类继承来的方法s，理论上不会影响同级类(比如B类，A、B继承了同一个父类)中的方法s，实际上本人做了实验也不会影响</li>
<li>如果只用Category拓展类中没有的方法的话，影响不大，但是如果要用Category重写类中的方法，一定要慎重，尤其是用Category重写系统提供的类（比如：<code>UIViewCtroller</code>、UITableView这些）的方法时，更要慎重，再慎重。因为用Category重写类中的方法会对子类造成很大的影响。比如：用Category重写了<code>UIViewCtroller</code>的方法A，那么如果你在工程中用到的所有继承自<code>UIViewCtroller</code>的子类，去调用方法A时，执行的都是Category中重写的方法A,如果不幸的是，你写的方法A有Bug，那么会造成整个工程中调用该方法的所有<code>UIViewCtroller</code>子类的不正常。除非你在子类中重写了父类的方法A，这样子类调用方法A时是调用的自己重写的方法A，消除了父类<code>Category</code>中重写方法对自己的影响<strong>&lt;重点，仔细阅读这段&gt;</strong></li>
<li>子类会不会继承父类的<code>Category</code>：<code>Category</code>中的重写方法会对子类造成影响，但是子类不会主动继承父类的<code>Category</code>中的非重写拓展方法。但是在子类中引入父类<code>Category</code>的声明文件后，子类就会继承<code>Category</code>里的非重写拓展方法。注意，是继承。而继承的具体表现就是：当子类里的方法和父类Category中的方法完全相同（这里的相同只除了方法体外的其他地方相同）时，那么子类里的方法会覆盖掉父类<code>Category</code>，因为这相当于子类重写了继承自父类的方法</li>
<li><code>Category</code>（类别）的影响是向下有效的.既会影响到该类所有子类.比如A类和B类继承自<code>Super</code>类，为A添加了一个类别<code>Gtr</code>,那么能使用该类别的仅限A类以及A的所有子类。B类是不能使用类别<code>Gtr</code>的</li>
</ul>
<h1 id="二、扩展（Extension）"><a href="#二、扩展（Extension）" class="headerlink" title="二、扩展（Extension）"></a>二、扩展（Extension）</h1><h4 id="Ⅰ-、扩展文件的创建"><a href="#Ⅰ-、扩展文件的创建" class="headerlink" title="Ⅰ 、扩展文件的创建"></a>Ⅰ 、扩展文件的创建</h4><p>1.新建文件<br>2.选择iOS平台Source中的Object-C Fie<br>3.选择File Type为Extension，则可建立相应类的扩展文件</p>
<h4 id="Ⅱ、扩展文件的特征"><a href="#Ⅱ、扩展文件的特征" class="headerlink" title="Ⅱ、扩展文件的特征"></a>Ⅱ、扩展文件的特征</h4><p>1.扩展文件为单一的.h文件<br>2.命名为”类名_类别名.h”</p>
<p>扩展文件格式<br>.m文件中的格式为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;类名.h&quot;</span><br><span class="line">@interface 类名 ()</span><br><span class="line">// 在此添加私有成员变量、属性、声明方法</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<h4 id="Ⅲ、扩展的作用"><a href="#Ⅲ、扩展的作用" class="headerlink" title="Ⅲ、扩展的作用"></a>Ⅲ、扩展的作用</h4><p>1.能为某个类附加额外的属性，成员变量，方法声明<br>2.一般的将类扩展直接写在.m文件中，而不单独建立类扩展文件<br>3.一般的私有属性和方法写到类扩展<br>4.和类别相似，但是小括号里面没有扩展的名字，就像匿名的类别</p>
<h4 id="Ⅳ、扩展的局限性"><a href="#Ⅳ、扩展的局限性" class="headerlink" title="Ⅳ、扩展的局限性"></a>Ⅳ、扩展的局限性</h4><ul>
<li>1.Extension中添加的属性、成员变量和方法属于私有属性和方法,(即：只能在本类的.m文件调用，如果在其他类里面，本类的对象是不可以调用声明的方法;这些属性和方法也不能被子类索继承),某些情况下，我们需要声明一个<code>@property</code>，它对外是只读的（<code>readonly</code>），而对内是可读写的（<code>readwrite</code>），这时，可以通过Extensions实现</li>
<li>2.一般的时候，Extension都是写在.m文件中，不单独建立一个扩展文件，且必须写在<code>@implementation</code>的上方，否则编译会报错。</li>
<li>3.类扩展定义的方法必须在类的实现中进行实现( 因为单独定义类的扩展的话 是只生产一个.h文件的，而类别是会生成.h .m两个文件的，因此 类别可以在自己的文件里面实现自己的实现方法，而扩展只能在需要扩展的类里面去进行扩展)。如果单独定义类扩展的文件并且只定义属性的话，也需要将类实现文件中包含进类扩展文件，否则会找不到属性的<code>set</code>和<code>get</code>方法。</li>
</ul>
<p>注：在我们自定义类的.m实现文件中，@interface部分即是该类的扩展。如我们创建的继承自<code>UIViewController</code>的类的.m文件代码如下</p>
<p>// 此乃本类的扩展</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;MyViewController.h&quot;</span><br><span class="line">@interface MyViewController ()</span><br><span class="line">// 在此声明方法，添加成员变量和属性</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MyViewController</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didReceiveMemoryWarning &#123;</span><br><span class="line">    [super didReceiveMemoryWarning];</span><br><span class="line">    // Dispose of any resources that can be recreated.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>当我们为<code>MyViewController</code>添加一个名为<code>MyViewController_Extension.h</code>的扩展时，可以看到<code>MyViewController_Extension.h</code>中的代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;MyViewController.h&quot;</span><br><span class="line">@interface MyViewController ()</span><br><span class="line">// 在此声明方法，添加成员变量和属性</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>可以看出，单独创建的扩展文件中的内容和.m实现文件中扩展的内容是一样的，当在<code>MyViewController.h</code>扩展文件中声明了方法，需要将<code>MyViewController_Extension.h</code>引入到<code>MyViewController.m</code>文件中，并在<code>MyViewController.m</code>文件中实现该方法</p>
<p>总结</p>
<h5 id="类别（Category）和扩展（Extension）的区别"><a href="#类别（Category）和扩展（Extension）的区别" class="headerlink" title="类别（Category）和扩展（Extension）的区别"></a>类别（Category）和扩展（Extension）的区别</h5><ul>
<li>1.类别只能扩充方法，不能扩展属性和成员变量（如果包含成员变量会直接报错）；如果分类中声明了一个属性，那么分类只会生成这个属性的set、get方法声明，也就是不会有实现</li>
<li>2.扩展有时也成为匿名类别</li>
</ul>
<h1 id="拓展：协议protocol"><a href="#拓展：协议protocol" class="headerlink" title="拓展：协议protocol"></a>拓展：协议protocol</h1><p>协议文件的创建<br>1.新建文件<br>2.选择iOS平台Source中的Object-C Fie<br>3.选择File Type为protocol，则可建立协议文件</p>
<p>协议文件的特征<br>1.协议文件为单一的.h文件<br>2.命名规则一般为”类名Delegate.h”</p>
<p>使用格式</p>
<h1 id="A类中定义了协议内容方法-A为委托方-“A委托B代理这些事务-B为代理”"><a href="#A类中定义了协议内容方法-A为委托方-“A委托B代理这些事务-B为代理”" class="headerlink" title="A类中定义了协议内容方法,A为委托方 “A委托B代理这些事务,B为代理”"></a>A类中定义了协议内容方法,A为委托方 “A委托B代理这些事务,B为代理”</h1><h4 id="h文件中的格式为"><a href="#h文件中的格式为" class="headerlink" title=".h文件中的格式为"></a>.h文件中的格式为</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># import &lt;Foundation/Foundation.h&gt; </span><br><span class="line">@protocol A协议名;</span><br><span class="line">@interface A类名</span><br><span class="line">&#123;   </span><br><span class="line">//代理对象的名称为:delegate</span><br><span class="line">    id &lt;A协议名&gt; _delegate;</span><br><span class="line">&#125;</span><br><span class="line">    //添加属性或者方法</span><br><span class="line">- (void) delegateMethod;  </span><br><span class="line">  </span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@protocol A类名 &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">// 在此声明A协议方法</span><br><span class="line">// @requires修饰的声明方法，代理方必须实现</span><br><span class="line">- (void) method;</span><br><span class="line">// @optional修饰的声明方法，代理方可以不实现</span><br><span class="line">- (void) optionalMethod;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="m文件中的格式为"><a href="#m文件中的格式为" class="headerlink" title=".m文件中的格式为"></a>.m文件中的格式为</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;A.h&quot;</span><br><span class="line">@implementatiom A类名 </span><br><span class="line">- (void) delegateMethod </span><br><span class="line">&#123;</span><br><span class="line">    if (_delegate)&#123;</span><br><span class="line">       [_delegate method];</span><br><span class="line">    &#125;</span><br><span class="line">    if (添加条件是否要求)&#123;</span><br><span class="line">        [_delegate optionalMethod]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h1 id="B为A的协议继承者-实现者"><a href="#B为A的协议继承者-实现者" class="headerlink" title="B为A的协议继承者,实现者"></a>B为A的协议继承者,实现者</h1><h4 id="h的文件格式为"><a href="#h的文件格式为" class="headerlink" title=".h的文件格式为:"></a>.h的文件格式为:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;A.h&quot;</span><br><span class="line">@interface B类名: NSObject &lt;A协议名&gt;</span><br><span class="line">&#123;</span><br><span class="line">    A *_a;  //定义一个指向A类对象的实例变量</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><strong>其中,B类声明她实现了A协议,只需要把协议名加载父类名称后面的&lt;&gt;内即可.</strong></p>
<h4 id="m的文件格式为"><a href="#m的文件格式为" class="headerlink" title=".m的文件格式为:"></a>.m的文件格式为:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;B.h&quot;</span><br><span class="line">@implementation B名称</span><br><span class="line">- (void) method //@require 方法必须全部实现,否则编译报错</span><br><span class="line">&#123;</span><br><span class="line">    //do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>使用方法<br>委托方将该协议文件导入自己的.h文件中，并添加一个遵守该协议的代理属性</p>
<p>注：<strong>就像一般把扩展写在.m文件中，而不单独建立一个扩展文件一样；一般开发中，不单独建立一个协议文件，而是将协议制定在委托方的.h文件中。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//分类需要创建专门类别类 </span><br><span class="line">@interface 类名 (类别名)</span><br><span class="line">//声明方法,如果需要声明属性,必须在runtime中实现getter/setter方法,而且_成员属性无法读取</span><br><span class="line">@end</span><br><span class="line">@implementation 类名 (类别名)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//扩展不需要专门创建一个文件,一般写在.m文件中@implementation 上方,否则编译报错</span><br><span class="line">@interface MyViewController ()</span><br><span class="line">// 在此声明方法，添加成员变量和属性</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation 类名</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//协议只需要在A类为委托方的.h文件中指定协议方法,谁继承了A类,必须完成它应尽的义务</span><br><span class="line">@protocol A协议名;//定义协议</span><br><span class="line">@interface A类名</span><br><span class="line">//属性,方法</span><br><span class="line">@end</span><br><span class="line">@protocol A类名 &lt;NSObject&gt;</span><br><span class="line">//协议方法</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/30/OC类别与类扩展-初探一/" data-id="cju1ian0v000a3j56x91666df" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-小记-变量异同" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/03/小记-变量异同/" class="article-date">
  <time datetime="2019-02-02T16:28:47.000Z" itemprop="datePublished">2019-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/03/小记-变量异同/">OC中变量之异同</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="成员变量（实例变量）-amp-局部变量区别："><a href="#成员变量（实例变量）-amp-局部变量区别：" class="headerlink" title="成员变量（实例变量）&amp;局部变量区别："></a>成员变量（实例变量）&amp;局部变量区别：</h2><p><strong><em>(1)作用域</em></strong></p>
<ul>
<li>成员变量：针对整个类有效。</li>
<li>局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)</li>
</ul>
<p><strong><em>(2)存储位置</em></strong></p>
<ul>
<li>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。</li>
<li>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。<br>当方法调用完，或者语句结束后，就自动释放。</li>
</ul>
<p><strong><em>(3)初始值</em></strong></p>
<ul>
<li>成员变量：有默认初始值。</li>
<li>局部变量：没有默认初始值，使用前必须赋值。</li>
</ul>
<h2 id="成员变量（实例变量）-amp-静态变量（类变量）区别："><a href="#成员变量（实例变量）-amp-静态变量（类变量）区别：" class="headerlink" title="成员变量（实例变量）&amp;静态变量（类变量）区别："></a>成员变量（实例变量）&amp;静态变量（类变量）区别：</h2><p><strong><em>A：调用方式</em></strong></p>
<ul>
<li>静态变量也称为类变量，可以直接通过类名调用。也可以通过对象名调用。属于类。</li>
<li><strong>成员变量也称为实例变量</strong>，只能通过对象名调用。这个变量属于对象。</li>
</ul>
<p><strong><em>B：存储位置</em></strong></p>
<ul>
<li>静态变量存储在方法区长中的静态区。</li>
<li>成员变量存储在堆内存。</li>
</ul>
<p><strong><em>C：生命周期</em></strong></p>
<ul>
<li>静态变量随着类的加载而存在，随着类的消失而消失。生命周期长。</li>
<li>成员变量随着对象的创建而存在，随着对象的消失而消失。</li>
</ul>
<p><strong><em>D：与对象的相关性</em></strong></p>
<ul>
<li>静态变量是所有对象共享的数据。</li>
<li>成员变量是每个对象所特有的数据。</li>
</ul>
<h2 id="全局变量与静态全局变量的区别"><a href="#全局变量与静态全局变量的区别" class="headerlink" title="全局变量与静态全局变量的区别"></a>全局变量与静态全局变量的区别</h2><p><strong>全局变量</strong></p>
<pre><code>存储方式：静态存储，存储在全局(静态)区
生命周期：静态存储方式决定了其生命周期为 从程序开始运行到程序结束
作用域：该程序的所有文件
</code></pre><p><strong>静态全局变量</strong></p>
<pre><code>存储方式：静态存储，存储在全局(静态)区
生命周期：静态存储方式决定了其生命周期为 从程序开始运行到程序结束
作用域：只有申明该变量的文件才可以访问到
</code></pre><p><strong>异同:</strong>    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">静态全局变量和全局变量的存储方式、生命周期是相同的。</span><br><span class="line">但是它们的作用域是不同的，全局变量在所有文件中都可以访问到，</span><br><span class="line">而静态全局变量只能在其申明的文件中才能访问到。</span><br><span class="line">也就是说，static改变了全局变量的作用域，从而达到对其他文件隐藏变量的目的</span><br></pre></td></tr></table></figure>
<h2 id="局部变量与静态局部变量的区别"><a href="#局部变量与静态局部变量的区别" class="headerlink" title="局部变量与静态局部变量的区别"></a>局部变量与静态局部变量的区别</h2><p><strong>局部变量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">存储方式：动态存储， 存储在堆(对象类型)或栈(数据类型)中</span><br><span class="line">生命周期：动态存储方式决定了其生命周期为变量使用期间</span><br><span class="line">作用域：方法和函数内，确切的说从申明到遇到 ‘&#125;‘ 为止。</span><br></pre></td></tr></table></figure>
<p><strong>静态局部变量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">存储方式：静态存储，存储在全局(静态)区</span><br><span class="line">生命周期：静态存储方式决定了其生命周期为 从程序开始运行到程序结束,静态更加&quot;持久&quot;</span><br><span class="line">作用域：方法和函数内，确切的说从申明到遇到 ‘&#125;‘ 为止。</span><br></pre></td></tr></table></figure>
<p><strong>异同</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">静态局部变量和局部变量的作用域是相同的。</span><br><span class="line">但是它们的存储方式是不同的，存储方式的不同导致了它们的生命周期也是不同的。</span><br><span class="line">也就是说static改变了局部变量的存储方式，从而达到保存变量的目的</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/03/小记-变量异同/" data-id="cju1ian0k00053j56d6l1c1ur" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/04/初探内存管理_二(ARC警告!)/">初探内存管理-二(ARC机制的使用规则)</a>
          </li>
        
          <li>
            <a href="/2019/04/03/源码资源-收集/">源码资源_收集</a>
          </li>
        
          <li>
            <a href="/2019/04/03/进程内存是如何分区的/">进程内存是如何分区的</a>
          </li>
        
          <li>
            <a href="/2019/04/02/初探内存管理-一/">初探内存管理(一)</a>
          </li>
        
          <li>
            <a href="/2019/04/02/类方法与实例方法/">类方法与实例方法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 ZHAO RUI<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>